#region Usings
#region Copyright
// (c) 2014 ELVEES NeoTek CJSC. All rights reserved.
// Closed source software. Actual software is delivered under the license agreement and (or) non-disclosure agreement.
// All software is copyrighted by ELVEES NeoTek CJSC (Russia) and may not be copying, publicly transmitted, modifying or distributed without prior written authorization from the copyright holder.
#endregion

using System;
using System.Collections.Concurrent;
using System.Threading;
using CCTV.Framework.Utility;
using JetBrains.Annotations;

#endregion

namespace Alnet.Common
{
   /// <summary>
   /// Provide sequential execution of operations enqueued from different threads in one of the threads that enqueue messages.
   /// </summary>
   /// <remarks>
   /// QueueProcessor that uses thread pool leads to event processing generated by queued actions are processed "later" and causing more additional updates.
   /// This class in hot-path scenario processes queued actions in the enqueueing thread, so in hot-path case events are already processed on Enqueue() return.
   /// Design of this class explicitly doesn't allow waiting for complete of any callbacks.
   /// Allowing waiting for this can lead to deadlocks, because if a code that calls Enqueue(callbackFunc) and wait for its finish would be itself executed in outerCallbackFunc 
   /// the deadlock occures, and there is no easy way to be sure that code is not executed inside a outerCallbackFunc in a complex system.
   /// </remarks>
   public sealed class InlineQueueProcessor
   {
      /// <summary>
      /// The queue of actions to process
      /// </summary>
      private readonly ConcurrentQueue<Action> _queueActions = new ConcurrentQueue<Action>();

      /// <summary>
      /// The synchronization object for sequential processing items from the queue
      /// </summary>
      private readonly object _syncProcessQueue = new object();

      /// <summary>
      /// flag indicating that actions should be dropped without execution
      /// </summary>
      private volatile bool _enableActionsDrop;

      /// <summary>
      /// enqueue action to execute. It will be executed (at some time), unless EnqueueFinal was already called.
      /// </summary>
      /// <param name="action">action to do</param>
      /// <remarks>
      /// Caller can NOT BE SURE that at this method return moment action is already executed.
      /// </remarks>>
      public void Enqueue([NotNull] Action action)
      {
         _queueActions.Enqueue(Guard.EnsureArgumentNotNull(action, "action"));
         processQueueInThisThread();
      }

      /// <summary>
      /// enqueue the action that must be final - after it's execution no other action will be executed. 
      /// </summary>
      /// <param name="finalAction">final action to do</param>
      /// <remarks>
      /// Caller can NOT BE SURE that at this method return moment finalAction is already executed.
      /// Caller cam BE SURE that actions passed to Enqueue after at this method return would never be executed.
      /// </remarks>>
      public void EnqueueFinal([NotNull] Action finalAction)
      {
         Guard.VerifyArgumentNotNull(finalAction, "finalAction");
         Enqueue(() =>
         {
            _enableActionsDrop = true;
            finalAction();
         });
      }

      /// <summary>
      /// Processes the queue <seealso cref="_queueActions"/> in one of the threads that calls this function
      /// </summary>
      private void processQueueInThisThread()
      {
         while (!_queueActions.IsEmpty)
         {
            if (!Monitor.TryEnter(_syncProcessQueue))
            {
               //some thread is working and will do all tasks
               return;
            }
            try
            {
               Action actionFromQueue = null;
               if (_queueActions.TryDequeue(out actionFromQueue) && !_enableActionsDrop)
               {
                  actionFromQueue();
               }
            }
            finally
            {
               Monitor.Exit(_syncProcessQueue);
            }
         }
      }
   }
}
